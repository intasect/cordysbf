<!--
	The default build file for Ant.
	!!DO NOT EDIT THIS FILE!!
	This file can be overwritten when an upgrade of the framework is done.
	
	Customizations should be done in the build-project.xml or the build-user.xml.
-->
<project default="all"
         basedir="."
         xmlns:artifact="antlib:org.apache.maven.artifact.ant"
>
	<import file="build-projectsite.xml" />
	
	<!--Pattern set which matches all Non CVS folders -->
	<patternset id="all.non.cvs.files">
		<include name="**/*" />
		<exclude name="**/CVS/**" />
	</patternset>

	<!--Pattern set which matches all Non VSS folders -->
	<patternset id="all.non.vss.files">
		<include name="**/*" />
		<exclude name="**/*.scc" />
	</patternset>

	<!--Pattern set which matches all Non Subversion folders -->
	<patternset id="all.non.svn.files">
		<include name="**/*" />
	 	<exclude name="**/.svn/**" />
		<exclude name="**/_svn/**" />
	</patternset>

	<!--Target for cleaning temporary distribution folders -->
	<target name="cleandist" unless="skip.clean">
		<delete dir="${dist.dir}" />
	</target>

	<!--Target for cleaning temporary build folders -->
	<target name="cleanbuild" unless="skip.clean">
		<delete dir="${build.dir}" />
	</target>

	<!--Target for cleaning all temporary distribution and build folders -->
	<target name="cleanall"
	        description="Cleans all output directories including build and dist"
	        depends="cleanbuild,cleandist"
	/>
	
	<!-- ================================= 
          target: publish
          This target will zip the ${dist.dir} and publish it into the Maven repository.
         ================================= -->
	<target name="publish"
	        depends="_check_publish,_base_publish"
	        description="--> This target publishes the artifact to maven repository."
	        unless="skip.publish"
	>
	</target>
	
	<!-- - - - - - - - - - - - - - - - - - 
          target: _check_publish                      
         - - - - - - - - - - - - - - - - - -->
    <target name="_check_publish">
    	<condition property="really.skip.publish">
    		<equals arg1="${skip.publish}" arg2="true" casesensitive="false" trim="true"/>
    	</condition>
    </target>


	<!-- ================================= 
          target: publish
          This target will zip the ${dist.dir} and publish it into the Maven repository.
         ================================= -->
	<target name="_base_publish"
	        description="--> This target publishes the artifact to maven repository."
	        unless="really.skip.publish"
	>
		<echo>Fixing the pom.xml</echo>
		<copy file="pom.xml" tofile="${build.dir}/pom.xml" />
		<replaceregexp file="${build.dir}/pom.xml"
		               match="\$\{version.full\}"
		               replace="${version.full}"
		               byline="true"
		/>

		<echo>Zipping the dist folder to publish it into the maven repository.</echo>
		<zip destfile="${build.dir}/${real.maven.publish.filename}"
		     basedir="${dist.dir}"
		>
		</zip>
		<echo>Publishing file ${isv.filename}_${isv.version}.zip</echo>
		<artifact:pom id="maven.pom.base" file="${maven.temp.pom}" />
		<artifact:deploy file="${build.dir}/${real.maven.publish.filename}">
			<pom refid="maven.pom.base" />
			<remoteRepository url="${maven.publish.remote.repository.url}">
				<authentication username="${maven.publish.remote.repository.username}"
				                password="${maven.publish.remote.repository.password}"
				/>
			</remoteRepository>
		</artifact:deploy>
		<delete file="${build.dir}/${real.maven.publish.filename}" />
	</target>
	
	<!-- - - - - - - - - - - - - - - - - - 
          target: _checkdefined
          
          This target executes the defflag macro on all properties that have true or false values.
          The macro is defined in the task-defs.xml file
         - - - - - - - - - - - - - - - - - -->
    <target name="_checkdefined">
    	<defflag property="skip.java"/>
    	<defflag property="skip.javadocs"/>
    	<defflag property="using.svn"/>
    	<defflag property="versionfile.generate"/>
    	<defflag property="dist.include.sources"/>
    	<defflag property="project.site.enabled" />
    	<defflag property="build.force.changelog" />
    	<available file="changelog.xml" property="changelog.file.exists"></available>
    	<defflag property="include.source" />
    </target>

	
	<!--Target for making folders for the build and distribution -->
	<target name="init"
	        depends="_checkdefined,cleanall,_check.skip.java"
	        unless="skip.init"
	>
		<mkdir dir="${build.dir}" />
		<mkdir dir="${build.classes}" />
		<mkdir dir="${build.jar}" />
		<mkdir dir="${build.web}" />
		<mkdir dir="${build.content}" />
		<mkdir dir="${build.isv}" />
		<mkdir dir="${build.test}" />
		<mkdir dir="${build.test.classes}" />
		<mkdir dir="${build.junitreports}" />
		<mkdir dir="${build.localizations}" />
		<mkdir dir="${dist.dir}" />
	</target>

	<!-- If property skip.java is set this sets the skip.javadocs as well as skip.test properties -->
	<target name="_check.skip.java" if="defined.skip.java">
		<echo>Skipping all Java content</echo>
		<property name="skip.test" value="true" />
		<property name="skip.javadocs" value="true" />
	</target>

	<!-- Copies coelib.version files found from the project to
		 the build directory and replaces @coelib.version@ tokens
		 with the actual version number. -->
	<target name="copy-coelib-version">
		<java classname="com.cordys.coe.coelib.LibraryVersion"
		      outputproperty="coelib.version"
		>
			<classpath refid="classpath" />
			<arg value="-number" />
		</java>

		<!-- Copy the coelib.version files to the classdir -->
		<copy todir="${build.classes}">
			<fileset dir="${src.java}">
				<patternset>
					<include name="**/coelib.version" />
				</patternset>
			</fileset>

			<filterchain>
				<replacetokens>
					<token key="coelib-version" value="${coelib.version}" />
				</replacetokens>
			</filterchain>
		</copy>
	</target>

	<!--Target for compiling java source files -->
	<target name="compile"
	        description="Compiles Java source files"
	        depends="init,copy-coelib-version"
	        unless="skip.java"
	>
		<javac srcdir="${src.java}"
		       destdir="${build.classes}"
		       debug="${javac.debug}"
		       deprecation="${javac.deprecation}"
		       optimize="${javac.optimize}"
		       source="${javac.source.version}"
		       target="${javac.target.version}"
		>
			<include name="**/*.java" />
			<classpath refid="classpath" />
		</javac>
		<!-- Copy the property-files to the classdir -->
		<copy todir="${build.classes}">
			<fileset dir="${src.java}">
				<patternset>
					<include name="**/*.properties" />
					<include name="**/*.xml" />
					<include name="**/*.gif" />
					<include name="**/*.ico" />
				</patternset>
			</fileset>
		</copy>
	</target>

	<!--Target for making jar file of the project in build folder -->
	<target name="jar"
	        description="Compiles Java sources and creates a JAR file"
	        depends="compile,generate-version-file"
	        unless="skip.java"
	>
		<tstamp>
			<format property="now" pattern="yyyyMMdd HH:mm" />
		</tstamp>
		<jar jarfile="${build.jar}/${project.jar.name}.jar"
		     basedir="${build.classes}"
		>
			<manifest>
				<attribute name="Build-Number" value="${version.full}" />
				<attribute name="Created-By" value="${isv.owner}" />
				<attribute name="Created-On" value="${now}" />
			</manifest>
		</jar>
	</target>
	
	<!-- ================================= 
	          target: generate-version-file              
	         ================================= -->
	<target name="generate-version-file"
	        if="defined.versionfile.generate"
	        depends="_generateprops,_checkdefined"
	        description="--> Generates and compiles the Version.java"
	>
		<!-- 
			First we need to replace to forward slashes with dots for the
			package name. Appearantly the only way to do this in Ant is using
			a temp file.
		-->
		<tstamp>
			<format property="versionfile.date" pattern="yyyy-MM-dd HH:mm" />
		</tstamp>

		<replaceproperty mode="java_fqn_to_path" 
						 srcvalue="${versionfile.class.package}"
						 destproperty="versionfile.class.path" />

		<!-- Copy the Java file and replace the next version parameter -->
		<copy file="${versionfile.template}"
		      tofile="${build.dir}/version/${versionfile.class.path}/${versionfile.class.name}.java"
		>
			<filterchain>
				<replacetokens>
					<token key="packagename"
					       value="${versionfile.class.package}"
					/>
					<token key="classname" value="${versionfile.class.name}" />
					<token key="majorminor" value="${project.version}" />
					<token key="milestonenumber"
					       value="${trim.milestone.number}"
					/>
					<token key="revisionnumber"
					       value="${svn.current.revision}"
					/>
					<token key="patchnumber" value="${trim.patch.number}" />
					<token key="builddate" value="${versionfile.date}" />
					<token key="productname"
					       value="${versionfile.productname}"
					/>
					<token key="generated" value="true" />
				</replacetokens>
			</filterchain>
		</copy>

		<!-- Compile the Version class -->
		<javac srcdir="${build.dir}/version/${versionfile.class.path}"
		       destdir="${build.classes}"
		       debug="false"
		       deprecation="true"
		       optimize="true"
			   source="${javac.source.version}"
			   target="${javac.target.version}"	
		>
			<include name="*.java" />
			<classpath refid="classpath" />
		</javac>
	</target>

	<!--Target for copying web resources to build folder -->
	<target name="web"
	        description="Copies web resources to the build folder"
	        depends="init"
	        unless="skip.web"
	>
		<copy todir="${build.web}">
			<fileset dir="${src.web}">
				<patternset refid="all.non.cvs.files" />
				<patternset refid="all.non.vss.files" />
				<patternset refid="all.non.svn.files" />
			</fileset>
		</copy>
	</target>

	<!-- Target for copying extra content to the build folder -->
	<target name="content"
	        description="Copies content to the build folder"
	        depends="init,web,zipprojectsource"
	>
		<copy todir="${build.content}/dbschema">
			<fileset dir="${src.content}/dbschema">
				<patternset refid="all.non.cvs.files" />
				<patternset refid="all.non.vss.files" />
				<patternset refid="all.non.svn.files" />
			</fileset>
		</copy>
	</target>
	
	<!--
		This target creates a zip file with the project's source.
	-->
	<target name="zipprojectsource" if="defined.include.source">
		<echo message="Creating project source zip"/>
		<zip destfile="${dist.dir}/${isv.filename}_${version.full}-src.zip">
		     <fileset dir="${basedir}">
		     	<include name="**/*"/>
		     	<exclude name="**/.svn/*"/>
		     	<exclude name="platform/**/*"/>
		     	<exclude name="sdk/**/*"/>
		     	<exclude name="dist/**/*"/>
		     	<exclude name="build/**/*"/>
		     	<exclude name="classes/**/*"/>
		     	<exclude name="user.properties"/>
		     </fileset>
		</zip>
	</target>

	<!--Copies the external docs to the build-folder. -->
	<target name="docs" depends="init" unless="skip.docs">
		<mkdir dir="${build.docs}" />
		<copy todir="${build.docs}">
			<fileset dir="${docs.external}">
				<patternset refid="all.non.cvs.files" />
				<patternset refid="all.non.vss.files" />
				<patternset refid="all.non.svn.files" />
			</fileset>
		</copy>
	</target>
	
	<!-- Target for creating the JavaDocs for the project -->
	<target name="javadocs" depends="init,_generateprops" unless="skip.javadocs">
		<mkdir dir="${build.apidocs}" />
		<javadoc packagenames="${javadoc.packagename}.*"
		         sourcepath="${src.java}"
		         destdir="${build.apidocs}"
		         author="${javadoc.author}"
		         version="${javadoc.version}"
		         use="${javadoc.use}"
		         private="${javadoc.private}"
		         windowtitle="${javadoc.windowtitle}"
		         doctitle="${project.name} ${version.full}"
		         source="${javac.source.version}"
		         stylesheetfile="${sdk.dir}/build/stylesheet.css"
		>
			<classpath refid="classpath" />
		</javadoc>
	</target>
	
	<!-- 
		This target creates a zipfile of the complete project. The 
		zip excludes the platform and sdk/lib folders.
	-->
	<target name="createsourcezip" if="defined.dist.include.sources">
			<mkdir dir="${dist.dir}/source"/>
			<zip destfile="${dist.dir}/source/source.zip">
				<fileset dir="${basedir}" casesensitive="yes">
					<patternset>
						<include name="**/*"/>
						<exclude name="build/**"/>
						<exclude name="dist/**"/>
						<exclude name="platform/**"/>
						<exclude name="sdk/lib/**"/>
						<exclude name="user.properties"/>
						<exclude name="build-user.xml"/>
						<exclude name="**/.svn/**"/>
						<exclude name="**/*.scc"/>
						<exclude name="**/CVS/**"/>
					</patternset>
				</fileset>
			</zip>
		</target>

	<!--Target for creating ISV package -->
	<target name="_isv"
	        depends="content,_isv-with-buildnumber,_isv-without-buildnumber"
	/>
	<target name="_isv-without-buildnumber"
	        description="Creates an ISV package"
	        depends="content"
	        unless="orig.patch.number"
	>
		<isv organization="${isv.org}"
		     owner="${isv.owner}"
		     productname="${isv.productname}"
		     version="${isv.version}"
		     type="standard"
		     name="${isv.name}"
		     filename="${isv.filename}"
		     destdir="${build.isv}"
		     copyisv="true"
		     userdn="${isv.userdn}"
			 build="${build.number.full}"
		>
			<content type="filesystem"
			         contentfile="${src.content}/isv/FileSystem.xml">
				<fileset>
					<patternset refid="all.non.cvs.files" />
					<patternset refid="all.non.vss.files" />
					<patternset refid="all.non.svn.files" />
				</fileset>
			</content>	
			<content type="systemenvironment"
			         contentfile="${src.content}/isv/SystemEnvironment.xml"
			/>
			<content type="prompts"
			         contentfile="${src.content}/isv/Prompts.xml"
			/>
			<content type="menus" contentfile="${src.content}/isv/Menus.xml" />
			<content type="toolbars"
			         contentfile="${src.content}/isv/Toolbars.xml"
			/>
			<content type="roles" contentfile="${src.content}/isv/Roles.xml" />
			<content type="applicationconnectors"
			         contentfile="${src.content}/isv/ApplicationConnector.xml"
			/>
			<content type="styles"
			         contentfile="${src.content}/isv/Styles.xml"
			/>
			<content type="xforms"
			         contentfile="${src.content}/isv/XForms.xml"
			/>
			<content type="xmlstore"
			         contentfile="${src.content}/isv/XMLStore.xml"
			/>
			<content type="studio"
			         contentfile="${src.content}/isv/Studio.xml"
			/>
			<content type="${handler.coboc.isv}"
			         contentfile="${src.content}/isv/CoBOC.xml"
			/>
			<content type="methodsets"
			         contentfile="${src.content}/isv/Methodsets.xml"
			/>
			<content type="wsappserver"
			         contentfile="${src.content}/isv/WsAppServer.xml"
			/>
			<content type="localizations"
			         contentfile="${src.content}/isv/Localizations.xml"
			/>
			<content type="xreports" 
					 contentfile="${src.content}/isv/XReports.xml"
					 optional="true"
			/>
			<content type="dependencies" 
					 contentfile="${src.content}/isv/Dependencies.xml"
					 optional="true"
			/>
		</isv>
	</target>

	<target name="_isv-with-buildnumber"
	        description="Creates an ISV package"
	        depends="content"
	        unless="skip.isv"
	        if="orig.patch.number"
	>
		<isv organization="${isv.org}"
		     owner="${isv.owner}"
		     productname="${isv.productname}"
		     version="${isv.realversion}"
		     type="standard"
		     name="${isv.name}"
		     filename="${isv.realfilename}"
		     destdir="${build.isv}"
		     copyisv="true"
		     userdn="${isv.userdn}"
			 build="${build.number.full}"
		>
			<content type="filesystem"
			         contentfile="${src.content}/isv/FileSystem.xml">
				<fileset>
					<patternset refid="all.non.cvs.files" />
					<patternset refid="all.non.vss.files" />
					<patternset refid="all.non.svn.files" />
				</fileset>
			</content>						
			<content type="systemenvironment"
			         contentfile="${src.content}/isv/SystemEnvironment.xml"
			/>
			<content type="prompts"
			         contentfile="${src.content}/isv/Prompts.xml"
			/>
			<content type="menus" contentfile="${src.content}/isv/Menus.xml" />
			<content type="toolbars"
			         contentfile="${src.content}/isv/Toolbars.xml"
			/>
			<content type="roles" contentfile="${src.content}/isv/Roles.xml" />
			<content type="applicationconnectors"
			         contentfile="${src.content}/isv/ApplicationConnector.xml"
			/>
			<content type="styles"
			         contentfile="${src.content}/isv/Styles.xml"
			/>
			<content type="xforms"
			         contentfile="${src.content}/isv/XForms.xml"
			/>
			<content type="xmlstore"
			         contentfile="${src.content}/isv/XMLStore.xml"
			/>
			<content type="studio"
			         contentfile="${src.content}/isv/Studio.xml"
			/>
			<content type="${handler.coboc.isv}"
			         contentfile="${src.content}/isv/CoBOC.xml"
			/>
			<content type="methodsets"
			         contentfile="${src.content}/isv/Methodsets.xml"
			/>
			<content type="wsappserver"
			         contentfile="${src.content}/isv/WsAppServer.xml"
			/>
			<content type="localizations"
			         contentfile="${src.content}/isv/Localizations.xml"
			/>
			<content type="xreports" 
					 contentfile="${src.content}/isv/XReports.xml"
					 optional="true"
			/>
			<content type="dependencies" 
					 contentfile="${src.content}/isv/Dependencies.xml"
					 optional="true"
			/>		         	
		</isv>
	</target>

	<!-- Loads project ISV's to ECX -->
	<target name="loadisv" description="Loads project ISV's to the ECX.">
		<isvload operation="load"
		         ldaphost="${ldap.server}"
		         ldapport="${ldap.port}"
		         ldappassword="${ldap.password}"
		         ldapuser="${ldap.user}"
		>
			<isvfile srcdir="${build.isv}" name="*${project.name}*" />
		</isvload>
	</target>

	<!-- Unloads project ISV's from ECX -->
	<target name="unloadisv" description="Unloads project ISV's from the ECX.">
		<isvload operation="unload"
		         ldaphost="${ldap.server}"
		         ldapport="${ldap.port}"
		         ldappassword="${ldap.password}"
		         ldapuser="${ldap.user}"
		>
			<isvfile name="*${project.name}*" />
		</isvload>
	</target>
	
	<!--Target for copying resources from build to distribution -->
	<target name="copy-dist" depends="copy-docs,copy-javadocs,copy-isv,copy-testreports,createsourcezip,_create-build-info">
	</target>

	<!--Target for copying resources from distribution to release area-->
	<target name="copy-release"
	        depends="copy-dist"
	        if="release.repository.path"
	>
		<mkdir dir="${release.repository.path}/${project.name}/Release-${version.full}"
		/>
		<copy todir="${release.repository.path}/${project.name}/Release-${version.full}"
		>
			<fileset dir="${dist.dir}">
				<patternset refid="all.non.cvs.files" />
				<patternset refid="all.non.vss.files" />
				<patternset refid="all.non.svn.files" />
			</fileset>
		</copy>
	</target>

	<!-- Target for copying the external documents to the dist-folder -->
	<target name="copy-docs" unless="skip.docs">
		<copy todir="${dist.docs}">
			<fileset dir="${build.docs}">
				<patternset refid="all.non.cvs.files" />
				<patternset refid="all.non.vss.files" />
				<patternset refid="all.non.svn.files" />
			</fileset>
		</copy>
		
		<if>
			<available file="${docs.external.dist}" />
			<then>
				<copy todir="${dist.docs}">
					<fileset dir="${docs.external.dist}">
						<patternset refid="all.non.cvs.files" />
						<patternset refid="all.non.vss.files" />
						<patternset refid="all.non.svn.files" />
					</fileset>
				</copy>
			</then>
		</if>
	</target>

	<!-- Target for copying the javadocs to the dist-folder -->
	<target name="copy-javadocs" unless="skip.javadocs">
		<copy todir="${dist.apidocs}">
			<fileset dir="${build.apidocs}">
				<patternset refid="all.non.cvs.files" />
				<patternset refid="all.non.vss.files" />
				<patternset refid="all.non.svn.files" />
			</fileset>
		</copy>
	</target>
	
	<!-- Target for copying the javadocs to the dist-folder -->
	<target name="copy-testreports" unless="skip.test">
		<copy todir="${dist.reports.junit}">
			<fileset dir="${build.junitreports}/html">
				<patternset refid="all.non.cvs.files" />
				<patternset refid="all.non.vss.files" />
				<patternset refid="all.non.svn.files" />
			</fileset>
		</copy>
		
		<copy todir="${dist.reports.cobertura}">
			<fileset dir="${build.cobertura.report}">
				<patternset refid="all.non.cvs.files" />
				<patternset refid="all.non.vss.files" />
				<patternset refid="all.non.svn.files" />
			</fileset>
		</copy>		
	</target>	

	<!-- Target for copying the jar-file to the dist folder -->
	<target name="copy-jar" if="defined.skip.isv">
		<copy todir="${dist.setup}">
			<fileset dir="${build.jar}">
				<include name="**/*.jar" />
			</fileset>
		</copy>
	</target>

	<!-- Target for copying the external documents to the dist-folder -->
	<target name="copy-isv" unless="skip.isv">
		<copy todir="${dist.setup}">
			<fileset dir="${build.isv}">
				<patternset refid="all.non.cvs.files" />
				<patternset refid="all.non.vss.files" />
				<patternset refid="all.non.svn.files" />
			</fileset>
		</copy>
	</target>
	
	<!-- Determines the actual testclasspath contents -->
	<target name="_determine-testclasspath">
		<if>
			<istrue value="${test.include.stubs}" />
			<then>
				<path id="actual-testclasspath">
					<fileset dir="${sdk.test.stubs.dir}">
						<include name="**/*.jar" />
					</fileset>	
					<path refid="testclasspath" />
				</path>
			</then>
			<else>
				<path id="actual-testclasspath">
					<path refid="testclasspath" />
				</path>
			</else>
		</if>
	</target>	
	
	<!--Target for compiling java unit test sources to build folder -->
	<target name="compile-test" depends="init,compile,_determine-testclasspath" unless="skip.test">
		<javac srcdir="${test.java}"
		       destdir="${build.test.classes}"
		       debug="true"
		       deprecation="${javac.deprecation}"
		       optimize="${javac.optimize}"
		       source="${javac.source.version}"
		       target="${javac.target.version}"
		>
			<include name="**/*.java" />
			<classpath>
				<path refid="actual-testclasspath" />
			</classpath>
		</javac>
	
		<!-- Copy the non-java files to the classdir -->
		<copy todir="${build.test.classes}">
			<fileset dir="${test.java}">
				<patternset>
					<exclude name="**/*.java" />
				</patternset>
				<patternset refid="all.non.cvs.files" />
				<patternset refid="all.non.vss.files" />
				<patternset refid="all.non.svn.files" />						
			</fileset>
		</copy>		
	</target>

	<!--Target for running tests -->
	<target name="test"
	        depends="init,compile-test,cobertura-instrument"
	        description="Runs the unit tests"
	        unless="skip.test"
	>
		<junit printsummary="yes" haltonfailure="no" fork="yes">
			<sysproperty key="net.sourceforge.cobertura.datafile"
			             file="${build.dir}/cobertura.ser"
			/>
			<classpath>
				<pathelement path="${build.cobertura.instrumented}" />
				<pathelement path="${build.classes}" />
				<pathelement path="${build.test.classes}" />
				<pathelement path="${build.test}" />
				<pathelement path="${build.jar}" />
				<path refid="actual-testclasspath" />
			</classpath>
			<formatter type="xml" usefile="true" />
			<batchtest todir="${build.junitreports}">
				<fileset dir="${test.java}">
					<include name="**/*Test.java" />
				</fileset>
			</batchtest>
		</junit>

		<!-- Do the Cobertura code checking -->
		<antcall target="cobertura-report" />

		<!-- Remove the properties as they can contain sensitive information -->
		<if>
			<istrue value="${junit.report.remove.properties}" />
			<then>
				<xmltask todir="${build.junitreports}">
					<fileset dir="${build.junitreports}">
						<include name="**/*.xml" />
					</fileset>		
					<replace path="//testsuite/properties" 
							 withXml="&lt;properties/&gt;" />
				</xmltask>
			</then>
		</if>	
		
		<!-- JUnit report -->
		<junitreport todir="${build.junitreports}">
			<fileset dir="${build.junitreports}">
				<include name="TEST-*.xml" />
			</fileset>
			<report styledir="${sdk.build.framework.dir}"
			        format="frames"
			        todir="${build.junitreports}/html"
			/>
		</junitreport>
		<!-- Fix the css -->
		<copy file="${junit.custom.css}" tofile="${build.junitreports}/html/stylesheet.css" overwrite="true"/>
	</target>

	<!-- - - - - - - - - - - - - - - - - - 
          target: cobertura-report
         - - - - - - - - - - - - - - - - - -->
	<target name="cobertura-report">
		<cobertura-report datafile="${build.dir}/cobertura.ser"
		                  srcdir="${src.java}"
		                  destdir="${build.cobertura.report}"
		                  format="html"
		/>
	</target>

	<!-- - - - - - - - - - - - - - - - - - 
          target: cobertura-instrument                      
         - - - - - - - - - - - - - - - - - -->
	<target name="cobertura-instrument" depends="init,compile,compile-test">
		<!--
				Remove the coverage data file and any old instrumentation.
			-->
		<delete file="${build.cobertura}/cobertura.ser" />
		<delete dir="${build.cobertura.instrumented}" />

		<!--
				Instrument the application classes, writing the
				instrumented classes into ${build.instrumented.dir}.
			-->
		<cobertura-instrument datafile="${build.dir}/cobertura.ser"
		                      todir="${build.cobertura.instrumented}"
		>
			<!--
					The following line causes instrument to ignore any
					source line containing a reference to log4j, for the
					purposes of coverage reporting.
				-->
			<ignore regex="org.apache.log4j.*" />

			<fileset dir="${build.classes}">
				<!--
						Instrument all the application classes, but
						don't instrument the test classes.
					-->
				<include name="**/*.class" />
				<exclude name="**/*Test.class" />
			</fileset>
		</cobertura-instrument>
	</target>

	<!--
		This target is to be used to make an official release. When making such a release both the
		milestone.number and the patch.number are increased.
		This target makes sure the working copy is up to date. First everything is updated. Then a
		status check is done to make sure there are no pending operations. If that is the case then
		both the patch.number and the milestone.number are increased. Then the property version.full is
		set the the actual version. The actual version is something like 1.0.001.0001
	-->
	<target name="release"
	        description="Creates a distribution of the project after running tests."
	        depends="cleanall,_labelrelease,_check_changelog,test,jar,docs,javadocs,_isv,copy-release,publish"
	>
	</target>

	<!--
		This target is to be used to make an official milestone. When making such a release the
		milestone.number is increased. It checks the working copy to see if there are pending 
		changes. If this is the case then a report is shown, but the build is not broken.
		Then the property version.full is set the the actual version. The actual version is 
		something like 1.0.001.0001.
		The updated build.number file is committed to the SVN-repository and a branch is created
		using the revision of the current working folder.
	-->
	<target name="milestone"
	        description="Creates a distribution of the project after running tests."
	        depends="cleanall,_labelmilestone,test,jar,docs,javadocs,_isv,copy-dist,publish,_make_svn_build_label"
	>
	</target>
	
	<!--
		This target is to be used to make an official release. When making such a release both the
		milestone.number and the patch.number are increased.
		The target is meant to be called from an external build tool . The resulting files (from the dist-folder)
		will be copied to the artifacts folder. 
		
		Important: The version numbers will be maintained by this project, NOT by the external builder.
		
		This target makes sure the working copy is up to date. First everything is updated. Then a
		status check is done to make sure there are no pending operations. If that is the case then
		both the patch.number and the milestone.number are increased. Then the property version.full is
		set the the actual version. The actual version is something like 1.0.001.0001
	-->
	<target name="snapshot"
	        description="Creates a distribution of the project after running tests."
	        depends="cleandist,_labelsnapshot,test,jar,docs,javadocs,_isv,copy-snapshot-release,publish,_make_svn_build_label"
	>
	</target>	

	<!-- 
		This target makes a developer's build. It checks the working copy to see if there are pending 
		changes. If this is the case then a report is shown, but the build is not broken.
	-->
	<target name="all"
	        description="Creates a distribution of the project after running tests."
	        depends="cleandist,_labelall,test,jar,docs,javadocs,_isv,copy-dist"
	>
	</target>
		
	<!--
		This target makes sure the working copy is up to date. First everything is updated. Then a
		status check is done to make sure there are no pending operations. If that is the case then
		both the patch.number and the milestone.number are increased. Then the property version.full is
		set the the actual version. The actual version is something like 1.0.001.0001
	-->
	<target name="_labelrelease"
	        depends="init"
	>
		<property name="defined.release.version.without.milestone" value="true"/>

		<if>
			<isset property="defined.using.svn" />
			<then>
				<exec-targets targetnames="_labelrelease_svn" />
			</then>
			<else>
				<exec-targets targetnames="_labelrelease_noscm" />
			</else>
		</if>
	</target>
	
	<!--
		This target is to be used to make an official milestone. When making such a release the
		milestone.number is increased. It checks the working copy to see if there are pending 
		changes. If this is the case then a report is shown, but the build is not broken.
		Then the property version.full is set the the actual version. The actual version is 
		something like 1.0.001.0001.
		The updated build.number file is committed to the SVN-repository and a branch is created
		using the revision of the current working folder.
	-->
	<target name="_labelmilestone"
	        depends="init"
	>
		<if>
			<isset property="defined.using.svn" />
			<then>
				<exec-targets targetnames="_labelmilestone_svn" />
			</then>
			<else>
				<exec-targets targetnames="_labelmilestone_noscm" />
			</else>
		</if>		
	</target>	

	<!--
		This target makes sure the working copy is up to date. First everything is updated. Then a
		status check is done to make sure there are no pending operations. If that is the case then
		both the patch.number and the milestone.number are increased. Then the property version.full is
		set the the actual version. The actual version is something like 1.0.001.0001
	-->
	<target name="_labelsnapshot"
	        depends="init,_generateprops"
	>
		<if>
			<isset property="defined.using.svn" />
			<then>
				<exec-targets targetnames="_labelsnapshot_svn" />
			</then>
			<else>
				<exec-targets targetnames="_labelsnapshot_noscm" />
			</else>
		</if>		
	</target>
	
	<!-- 
		This target makes a developer's build. It checks the working copy to see if there are pending 
		changes. If this is the case then a report is shown, but the build is not broken.
	-->
	<target name="_labelall" depends="init">
		<if>
			<isset property="defined.using.svn" />
			<then>
				<exec-targets targetnames="_labelall_svn" />
			</then>
			<else>
				<exec-targets targetnames="_labelall_noscm" />
			</else>
		</if>			
	</target>	

	<!--
		The target for labeling the release if the project is under subversion.
	-->
	<target name="_labelrelease_svn"
	        if="defined.using.svn"
	        depends="_updateworkingcopy,_labelrelease_inc,_generateprops"
	>
	</target>

	<!--
		This target labels the milestone if the project is under subversion.
	-->
	<target name="_labelmilestone_svn"
	        if="defined.using.svn"
	        depends="_updateworkingcopy,_labelmilestone_inc,_generateprops"
	>
	</target>
	
	<!--
		The target for labeling the release if the project is under subversion.
	-->
	<target name="_labelsnapshot_svn"
	        depends="_updateworkingcopy,_generateprops"
	        if="defined.using.svn"
	>
	</target>

	<!--
		This target is used if the project is under subversion.
	-->
	<target name="_labelall_svn"
	        depends="_checkworkingcopy,_generateprops"
	        if="defined.using.svn"
	>
	</target>

	<!--
		Target for labeling the release if the project is not under subversion.
	-->
	<target name="_labelrelease_noscm"
	        depends="_labelrelease_inc,_generateprops"
	        unless="using.svn"
	>
	</target>
		
	<!--
		This target labels the milestone if the project is not under subversion.
	-->
	<target name="_labelmilestone_noscm"
	        depends="_labelmilestone_inc,_generateprops"
	        unless="using.svn"
	>
	</target>

	<!--
		Target for labeling the release if the project is not under subversion.
	-->
	<target name="_labelsnapshot_noscm" unless="using.svn">

		<!-- Set the variables based on the version -->
		<property name="version.full"
		          value="${project.version}.${trim.patch.number}.${trim.milestone.number}.snapshot"
		/>
		<property name="isv.realfilename"
		          value="${isv.filename}_${version.full}"
		/>
		<property name="isv.realversion"
		          value="${isv.version} Build ${version.full}"
		/>

		<tstamp>
			<format property="now" pattern="yyyyMMdd_HHmm" />
		</tstamp>
	</target>
	
	<!--
		This target is used if the project is not under subversion.
	-->
	<target name="_labelall_noscm" depends="_generateprops" unless="using.svn">
		<!-- Set the variables based on the version -->
		<property name="version.full"
		          value="${project.version}.${trim.patch.number}.${trim.milestone.number}.dev"
		/>
		<property name="isv.realfilename"
		          value="${isv.filename}_${version.full}"
		/>
		<property name="isv.realversion"
		          value="${isv.version} Build ${version.full}"
		/>
	</target>
	
	<!-- - - - - - - - - - - - - - - - - - 
          target: _labelrelease_inc
         - - - - - - - - - - - - - - - - - -->
	<target name="_labelrelease_inc">
		<!-- This target updates the patch number in the build.number file -->
		<propertyfile file="build.number"
		              comment="Project's next build number."
		>
			<entry key="patch.number"
			       type="int"
			       default="000"
			       operation="+"
			       pattern="000"
			/>
			<entry key="milestone.number"
			       type="string"
				   operation="="
			       value="000"
			/>			
		</propertyfile>
	</target>

	<!-- - - - - - - - - - - - - - - - - - 
          target: _labelmilestone_inc
         - - - - - - - - - - - - - - - - - -->
	<target name="_labelmilestone_inc">
		<!-- This target updates the patch number in the build.number file -->
		<propertyfile file="build.number"
		              comment="Project's next build number."
		>
			<entry key="milestone.number"
			       type="int"
			       default="000"
			       operation="+"
			       pattern="000"
			/>
		</propertyfile>
	</target>
			
	<!--
		This target generates the trimmed version numbers. The result of this target
		are a couple of properties:
		trim.patch.number -> patch.number without leading zeros.
		trim.milestone.number -> milestone.number without leading zeros.
		orig.patch.number -> patch.number padded with zeros
		orig.milestone.number -> milestone.number padded with zeros
		
		It firthermore sets these properties:
		version.full -> The full version number with leading zeros removed.
		version.svn.full -> The full version number with leading zeros intact.
		isv.realfilename -> The filename for the ISV.
		isv.realversion -> The real version number for the ISV package.
		
		This target also takes into account that it could be a snapshot build.
		If it's a snapshot build the patch.number will be filled with the current
		date. The milestone.number will be expexted to be passed on by the
		snapshot-build software via the property:
		extbuilder.snapshot.version
	-->
	<target name="_generateprops" depends="_gp_normal,_gp_snapshot">
		<property file="${build.dir}/tmp.properties" />
		
		<if>
			<isset property="defined.release.version.without.milestone" />
			<then>
				<property name="version.full"
				          value="${version.prefix}${project.version}.${trim.patch.number}${version.postfix}"
				/>
				<property name="version.svn.full"
				          value="${version.prefix}${project.version}.${orig.patch.number}${version.postfix}"
				/>	
				<property name="build.number.full"
				          value="${trim.patch.number}${version.postfix}"
				/>				
			</then>
			<else>
				<property name="version.full"
				          value="${version.prefix}${project.version}.${trim.patch.number}.${trim.milestone.number}${version.postfix}"
				/>
				<property name="version.svn.full"
				          value="${version.prefix}${project.version}.${orig.patch.number}.${orig.milestone.number}${version.postfix}"
				/>
				<property name="build.number.full"
				          value="${trim.patch.number}.${trim.milestone.number}${version.postfix}"
				/>					          	
			</else>
		</if>
			
		<property name="isv.realfilename"
		          value="${isv.filename}_${version.full}"
		/>
		<property name="isv.realversion"
		          value="${isv.version} Build ${version.full}"
		/>

		<!-- Now create the name that will be used for the maven publish -->
		<concat append="false" destfile="${build.dir}/mavenname.properties">real.maven.publish.filename=${maven.publish.filename}</concat>
		<replaceregexp file="${build.dir}/mavenname.properties"
		               match=" "
		               replace="_"
		               byline="true"
		/>
		<property file="${build.dir}/mavenname.properties" />

		<!-- Now we need to create the proper pom.xml with the newly generated version -->
		<if>
			<available file="pom.xml" />
			<then>		
				<copy file="pom.xml" tofile="${maven.temp.pom}" />
				<replaceregexp file="${maven.temp.pom}"
				               match="\$\{version.full\}"
				               replace="${version.full}"
				               byline="true"
				/>
			</then>
		</if>		
	</target>

	<!-- - - - - - - - - - - - - - - - - - 
          target: _gp_check
          This target checks if the extbuilder.using is set.
         - - - - - - - - - - - - - - - - - -->
	<target name="_gp_check">
		<condition property="gp.do.snapshot">
			<and>
				<isset property="extbuilder.snapshot" />
				<isset property="extbuilder.snapshot.version" />
			</and>
		</condition>
	</target>

	<!-- - - - - - - - - - - - - - - - - - 
          target: _gp_normal                      
         - - - - - - - - - - - - - - - - - -->
	<target name="_gp_normal" depends="_gp_check" unless="gp.do.snapshot">
		<property file="build.number" />
		<property name="version.prefix" value="${release.version.prefix}" />
		<property name="version.postfix" value="${release.version.postfix}" />
		<propertyfile file="${build.dir}/tmp.properties"
		              comment="Temporary properties."
		>
			<entry key="trim.patch.number"
			       type="int"
			       pattern="0"
			       default="${patch.number}"
			/>
			<entry key="trim.milestone.number"
			       type="int"
			       pattern="0"
			       default="${milestone.number}"
			/>
			<entry key="orig.patch.number"
			       type="int"
			       pattern="000"
			       default="${patch.number}"
			/>
			<entry key="orig.milestone.number"
			       type="int"
			       pattern="0000"
			       default="${milestone.number}"
			/>
		</propertyfile>
	</target>

	<!-- - - - - - - - - - - - - - - - - - 
          target: _gp_snapshot                      
         - - - - - - - - - - - - - - - - - -->
	<target name="_gp_snapshot" depends="_gp_check" if="gp.do.snapshot">
		<property file="build.number" />
		<property name="version.prefix" value="${snapshot.version.prefix}" />
		<property name="version.postfix" value="${snapshot.version.postfix}" />
		<tstamp>
			<format property="tmp1.timestamp" pattern="yyyyMMdd" />
		</tstamp>
		<propertyfile file="${build.dir}/tmp.properties"
		              comment="Temporary properties."
		>
			<entry key="trim.patch.number"
			       type="int"
			       pattern="0"
			       default="${tmp1.timestamp}"
			/>
			<entry key="trim.milestone.number"
			       type="int"
			       pattern="0"
			       default="${extbuilder.snapshot.version}"
			/>
			<entry key="orig.patch.number"
			       type="int"
			       pattern="000"
			       default="${tmp1.timestamp}"
			/>
			<entry key="orig.milestone.number"
			       type="int"
			       pattern="0000"
			       default="${extbuilder.snapshot.version}"
			/>
		</propertyfile>
	</target>

	<!-- - - - - - - - - - - - - - - - - - 
          target: _updateworkingcopy
         - - - - - - - - - - - - - - - - - -->
	<target name="_updateworkingcopy" if="defined.using.svn">
		<!-- Revert the build.number file in case we had a failed build and are trying again -->
		<svn username="${svn.username}">
			<revert file="build.number" />
		</svn>		
		
		<svn username="${svn.username}">
			<info target="${user.dir}" />
		</svn>
		
		<!-- This target updates the local working copy -->
		<svn username="${svn.username}">
			<update dir="." recurse="true" />
		</svn>
		<svn username="${svn.username}">
			<coelog path="." propLatestRevision="svn.current.revision" />
		</svn>
		<svn username="${svn.username}">
			<coelog url="${svn.info.url}"
			     propLatestRevision="svn.latest.revision"
			/>
		</svn>
		<!-- Do the status check -->
		<svn username="${svn.username}">
			<coestatuscheck path="." failOnModification="true" excludePattern="build.number$"/>
		</svn>
	</target>

	<!-- - - - - - - - - - - - - - - - - - 
          target: _checkworkingcopy
         - - - - - - - - - - - - - - - - - -->
	<target name="_checkworkingcopy" if="defined.using.svn">
		<svn username="${svn.username}">
			<info target="." />
		</svn>
		<svn username="${svn.username}">
			<coelog path="." propLatestRevision="svn.current.revision" />
		</svn>
		<svn username="${svn.username}">
			<coelog url="${svn.info.url}"
			     propLatestRevision="svn.latest.revision"
			/>
		</svn>
		<echo message="Working folder revision: ${svn.current.revision}" />
		<echo message="Latest revision in the repository: ${svn.latest.revision}"
		/>

		<!-- Update the build.number file -->
		<svn username="${svn.username}">
			<update file="build.number" />
		</svn>
		<!-- Do the status check -->
		<svn username="${svn.username}">
			<coestatuscheck path="." failOnModification="false" />
		</svn>
	</target>

	<!-- - - - - - - - - - - - - - - - - - 
          target: _make_svn_build_label                      
         - - - - - - - - - - - - - - - - - -->
	<target name="_make_svn_build_label" if="defined.using.svn">
		<!-- First check that we have the current working copy SVN revision -->
		<check-property property="svn.current.revision" />
		
		<echo>Creating a label from project revision ${svn.current.revision}</echo>
		
		<!-- Set the branch timestamp -->
		<tstamp>
			<format property="make.svn.copy.now" pattern="yyyyMMdd_HHmm" />
		</tstamp>
		
		<!-- Create a temporary folder under the build folder for the branch root files -->
		<mkdir dir="${build.dir}/tmp-branch-checkout" />

		<!--  Create the branch in SubVersion from the working copy revision -->
		<svn username="${svn.username}">
			<copy srcUrl="${svn.main}"
			      destUrl="${svn.branches}/${svn.label}_${version.svn.full}"
			      message="Build ${version.full} on ${make.svn.copy.now}"
				  revision="${svn.current.revision}"
			>
			</copy>
		</svn>
	
		<!-- Checkout the root folder of this branch under a temporary folder -->
		<svn username="${svn.username}">
			<checkout url="${svn.branches}/${svn.label}_${version.svn.full}" 
				      destPath="${build.dir}/tmp-branch-checkout" 
					  recurse="false"
			/>
  		</svn>
		
		<!-- Copy the build number to the branch folder -->
		<copy file="build.number" 
			  tofile="${build.dir}/tmp-branch-checkout/build.number" 
			  overwrite="true"/>
		
		<!-- Commit the new buildnumbers to the repository -->
		<svn username="${svn.username}">
			<commit message="Updated the buildnumber (build ${version.full})">
				<fileset file="build.number" />
			</commit>
		</svn>
		<svn username="${svn.username}">
			<commit message="Updated the buildnumber (build ${version.full})">
				<fileset file="${build.dir}/tmp-branch-checkout/build.number" />
			</commit>
		</svn>		

		<!-- Delete the temporary branch folder -->
		<delete dir="${build.dir}/tmp-branch-checkout" />
	</target>
	
	<!--
		This target displays the version of the buildframework.
	-->
	<target name="show-versions"
	        description="This target displays the version of the buildframework"
	>
		<bfversion />
	</target>

	<!-- This target copies the files to the lunt area -->
	<target name="copy-snapshot-release" depends="copy-dist">
		<!-- First copy the test results. -->
		<junitreport todir="${build.junitreports}">
			<fileset dir="${build.junitreports}">
				<include name="TEST-*.xml" />
			</fileset>
			<report format="frames"
			        styledir="${sdk.build.framework.dir}"
			        todir="${extbuilder.junit.htmlreport}"
			/>
		</junitreport>

		<!-- Cobertura report -->
		<cobertura-report datafile="${build.dir}/cobertura.ser"
		                  srcdir="${src.java}"
		                  destdir="${extbuilder.junit.htmlreport}"
		                  format="html"
		/>

		<mkdir dir="${extbuilder.output.dir}/Release-${version.full}" />
		<copy todir="${extbuilder.output.dir}/Release-${version.full}">
			<fileset dir="${dist.dir}">
				<patternset refid="all.non.cvs.files" />
				<patternset refid="all.non.vss.files" />
				<patternset refid="all.non.svn.files" />
			</fileset>
		</copy>
	</target>
</project>
